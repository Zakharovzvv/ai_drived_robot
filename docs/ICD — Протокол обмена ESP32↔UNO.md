# ICD — Протокол обмена ESP32↔UNO (I²C) — v0.1

> Межблочный интерфейс между **ESP32‑S3 (master)** и **Arduino UNO (slave @0x12)**. Протокол регистровый, с двухшаговым коммитом (SEQ) для атомарного применения команд. Совместим с электрической схемой из «Электрика и проводка робота (RBM) — v0.3».

---

## 1. Шина и базовые правила

* **Физика:** I²C, 400 кГц, внешние pull‑up 4.7–10 кОм к **3.3V**, общий GND.
* **Роли:** ESP32 — master, UNO — slave `0x12`.
* **Пакеты:** стандартные I²C операции записи/чтения регистров (адрес регистра + данные).
* **Эндианность:** **little‑endian** для всех многобайтных полей.
* **Цикл обновления:** 20–50 мс (рекомендуем 25 мс). **Таймаут тишины:** 200 мс → UNO выполняет BRAKE (1500 µs всем сервоканалам) и выставляет флаг `ERR_TIMEOUT`.
* **Атомарность:** блоки команд пишутся в «теневые» регистры; применение — запись нового `SEQ` (либо запись в `APPLY`). UNO применяет только если `SEQ != SEQ_ACK`.

---

## 2. Типы и масштабы

* `int16` — знаковый 16‑бит, `uint16` — беззнаковый 16‑бит, `uint8` — 8‑бит.
* Единицы и масштабы:

  * **Скорости:** мм/с (`vx`, `vy`), мрад/с (`wz_mrad_s`).
  * **Позиции подъёма:** мм (`elev_mm`).
  * **Захват:** градусы вала (`grip_deg`) — пересчёт из потенциометра (см. §7.4).
  * **Время:** мс (`t_ms`).
  * **Сервосигнал:** микросекунды (`us`) — диагностическое значение.

---

## 3. Карта регистров UNO (адрес — смещение от 0x00)

### 3.1 Команды (ESP32 → UNO, **write**)

| Адрес | Имя   | Типы / поля                                                        | Описание                                                                              |
| ----: | ----- | ------------------------------------------------------------------ | ------------------------------------------------------------------------------------- |
|  0x00 | DRIVE | int16 `vx_mm_s`, int16 `vy_mm_s`, int16 `wz_mrad_s`, uint16 `t_ms` | Вектор движения шасси (механум) и длительность исполнения.                            |
|  0x10 | ELEV  | int16 `pos_mm`, uint16 `vmax_mm_s`, uint16 `amax_mm_s2`            | Цель по лифту и ограничения профиля.                                                  |
|  0x18 | GRIP  | uint8 `mode`, int16 `pose_deg`, uint8 `spd_pct`                    | 0=OPEN, 1=CLOSE, 2=POSE(угол в `pose_deg`), `spd_pct` 0..100.                         |
|  0x1C | BRAKE | uint8 `on`                                                         | 1=сбросить все Servo к 1500 µs и удерживать до сброса.                                |
|  0x1D | HOME  | uint8 `mask`                                                       | Бит0=лифт homing, Бит1=захват homing (калибровка нулей).                              |
|  0x1E | SEQ   | uint8 `seq`                                                        | **Коммит**: увеличить значение на 1 для применения всех изменённых блоков.            |
|  0x1F | APPLY | uint8 `mask`                                                       | Альтернатива SEQ: Бит0=DRIVE, Бит1=ELEV, Бит2=GRIP. Применяет только указанные блоки. |

> Примечание: предпочтительно использовать **SEQ**. UNO сравнивает `SEQ` с `SEQ_ACK` (см. 3.2) и применяет все изменённые команды одной транзакцией.

### 3.2 Статус и телеметрия (UNO → ESP32, **read**)

| Адрес | Имя     | Типы / поля                                                             | Описание                                                      |
| ----: | ------- | ----------------------------------------------------------------------- | ------------------------------------------------------------- |
|  0x40 | STATUS0 | uint8 `state_id`, uint8 `seq_ack`, uint16 `err_flags`                   | Состояние, подтверждённый SEQ, флаги ошибок.                  |
|  0x44 | STATUS1 | int16 `elev_mm`, int16 `grip_pos_deg`                                   | Положение лифта (мм) и захвата (град).                        |
|  0x48 | LINES   | uint16 `lineL_adc`, uint16 `lineR_adc`, uint16 `line_thr`               | Сырые АЦП значений трекеров и текущий порог.                  |
|  0x4E | POWER   | uint16 `vbatt_mV`, uint8 `mps_state`, uint8 `estop_state`               | Напряжение батареи, `mps`:0/1, `estop`:0/1.                   |
|  0x50 | DRIVEFB | uint16 `fl_us`, `fr_us`, `rl_us`, `rr_us`                               | Текущие цели сервосигналов колёс (диагностика).               |
|  0x58 | AUXFB   | uint16 `lift_us`, uint16 `grip_us`                                      | Сервосигналы лифта/захвата (диагностика).                     |
|  0x5C | SENS    | uint16 `pot_raw`, int16 `lift_enc_cnt`                                  | Сырой потенциометр захвата (0..1023), счётчик энкодера лифта. |
|  0x60 | FWINFO  | uint8 `proto_ver`, uint8 `fw_major`, uint8 `fw_minor`, uint8 `fw_patch` | Версии протокола/прошивки.                                    |

#### 3.3 Конфигурация/калибровка (необязательные, **read/write**, применяются по SEQ)

| Адрес | Имя      | Типы / поля                                             | Описание                                                      |
| ----: | -------- | ------------------------------------------------------- | ------------------------------------------------------------- |
|  0x70 | CFG_LINE | uint16 `line_thr`                                       | Фиксированный порог линии; `0` = автокалибровка на старте.    |
|  0x72 | CFG_LIFT | uint16 `enc_per_mm`, int16 `h1_mm`, `h2_mm`, `h3_mm`    | Калибровка лифта: тики на мм и уровни полок.                  |
|  0x7A | CFG_GRIP | uint16 `pot_min`, `pot_max`, int16 `deg_min`, `deg_max` | Калибровка захвата: пересчёт сырого `pot_raw`→`grip_pos_deg`. |

---

## 4. Коды состояний и ошибок

### 4.1 `state_id`

* `0` — BOOT (инициализация)
* `1` — IDLE (готов к приёму команд)
* `2` — DRIVE (исполнение вектора движения)
* `3` — ELEV_MOVE (движение лифта)
* `4` — GRIP_MOVE (движение захвата)
* `5` — HOMING
* `6` — BRAKE (принудительная остановка)

### 4.2 `err_flags` (битовая маска)

* `0x0001` `ERR_TIMEOUT` — таймаут команд от ESP32 (>200 мс)
* `0x0002` `ERR_I2C` — ошибка шины
* `0x0004` `ERR_ESTOP` — программный вход MPS/E‑STOP активен
* `0x0008` `ERR_LIFT_HOMING` — ошибка калибровки лифта
* `0x0010` `ERR_LIFT_STALL` — лифт не двигается по энкодеру
* `0x0020` `ERR_GRIP_RANGE` — потенциометр вне диапазона (A3)
* `0x0040` `ERR_DRIVE_RANGE` — команда DRIVE вне лимитов
* `0x0080` `ERR_CFG` — некорректные калибровки
* `0x0100` `WARN_LOW_BATT` — низкое напряжение батареи

UNO сбрасывает флаги по событиям: `SEQ` или отдельной записью в `BRAKE=0` (для `ERR_TIMEOUT/ERR_ESTOP`).

---

## 5. Поведение, временные диаграммы

* **Коммит по SEQ:** ESP32 пишет блоки `DRIVE/ELEV/GRIP` → пишет `SEQ=prev+1`. UNO: считывает изменения, применяет в одном такте, копирует значение в `SEQ_ACK` (STATUS0).
* **Таймаут:** если за 200 мс не было новых `SEQ`/`APPLY` и активных команд, UNO переходит в BRAKE.
* **Приоритеты:** `BRAKE` > `HOME` > `ELEV/GRIP` > `DRIVE`.
* **HOME:** при `HOME.bit0=1` UNO выполняет homing лифта и обновляет ноль энкодера; при `HOME.bit1=1` — ноль потенциометра захвата по текущему `pot_raw`.

---

## 6. Примеры транзакций

### 6.1 Движение на 300 мс вперёд, без поворота

1. Запись в `DRIVE` (0x00): `vx=200`, `vy=0`, `wz=0`, `t=300` (8 байт).
2. Запись `SEQ` (0x1E): `seq=7` → UNO применяет, `SEQ_ACK=7`.

### 6.2 Поднять лифт на 120 мм с ограничениями

1. Запись `ELEV` (0x10): `pos_mm=120`, `vmax=120`, `amax=400`.
2. `SEQ=8`.

### 6.3 Поставить захват в позицию 35° с 60% скорости

1. Запись `GRIP` (0x18): `mode=2`, `pose_deg=35`, `spd_pct=60`.
2. `SEQ=9`.

### 6.4 Аварийный тормоз

1. Запись `BRAKE` (0x1C): `on=1`.
2. Любая следующая команда снимает тормоз (`BRAKE=0`) и `SEQ=+1`.

---

## 7. Преобразования и калибровки (реализация на UNO)

### 7.1 DRIVE → Servo (колёса)

* Раскладка механума:

  * `fl = vx - vy - k*ω`, `fr = vx + vy + k*ω`, `rl = vx + vy - k*ω`, `rr = vx - vy + k*ω`.
* Нормировка к диапазону Servo (1000..2000 µs) с мёртвой зоной вокруг 1500 µs.
* Плавность: S‑кривые ускорений; лимит по абсолютной дельте за такт.

### 7.2 Лифт (энкодер)

* ПИД позиционирования; `enc_per_mm` задаёт масштаб (см. CFG_LIFT).
* Уровни H1/H2/H3 из CFG_LIFT. Homing по упору/метке, далее абсолютные мм.

### 7.3 Захват (потенциометр)

* Пересчёт `pot_raw (0..1023)` → `grip_pos_deg` по CFG_GRIP: линейная интерполяция между (`pot_min`,`deg_min`) и (`pot_max`,`deg_max`).
* Режимы: OPEN/CLOSE — используют пресеты (`deg_min`/`deg_max`), POSE — абсолютный угол. Ограничения скорости по `spd_pct`.

### 7.4 Линия

* АЦП A0/A1 усредняются; если `CFG_LINE.line_thr=0` — автокалибровка на старте. В STATUS выдаётся текущий порог.

---

## 8. Ограничения и совместимость

* Максимальные значения по умолчанию: `|vx|,|vy| ≤ 400 мм/с`, `|wz| ≤ 2000 мрад/с`, `t_ms ≤ 2000`. Пределы можно расширить после стендовых тестов.
* Все новые поля/регистры обязаны иметь резервирование в конце блока.
* `proto_ver` в `FWINFO` должен инкрементироваться при несовместимых изменениях.

---

## 9. Чек‑лист интеграции

* [ ] ESP32 Wire: период цикла 25 мс, пакет `DRIVE/ELEV/GRIP` + `SEQ`.
* [ ] Обработать `ERR_TIMEOUT`, `ERR_ESTOP` — немедленный переход BT в «ожидание».
* [ ] При расхождении `SEQ` и `SEQ_ACK` более 100 мс — повторить последнюю транзакцию.
* [ ] Логировать `STATUS`, `LINES`, `POWER` на ESP32 для авто‑калибровок.

---

## 10. Приложение A — адреса/длины для блочных операций

* `DRIVE` 0x00..0x07 (8 байт)
* `ELEV`  0x10..0x15 (6 байт)
* `GRIP`  0x18..0x1B (4 байта)
* `STATUS0` 0x40..0x43 (4 байта)
* `STATUS1` 0x44..0x47 (4 байта)
* `LINES`   0x48..0x4D (6 байт)
* `POWER`   0x4E..0x51 (4 байта)
* `DRIVEFB` 0x50..0x57 (8 байт)
* `AUXFB`   0x58..0x5B (4 байта)
* `SENS`    0x5C..0x5F (4 байта)
* `FWINFO`  0x60..0x63 (4 байта)
* `CFG_LINE` 0x70..0x71 (2 байта)
* `CFG_LIFT` 0x72..0x79 (8 байт)
* `CFG_GRIP` 0x7A..0x81 (8 байт)

---

**Готово.** Этот ICD покрывает командные/статусные окна, поведение SEQ/APPLY, коды состояний/ошибок, примеры транзакций и калибровки. Следующим шагом предлагаю сделать **skeleton‑коды**: `uno/` (Servo + энкодер + pot + line + I²C + MPS) и `esp32/` (i2c_link + FSM/BT + демо‑команды по ICD).
